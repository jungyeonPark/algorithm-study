# 알고리즘 설명

## BFS(Breadth First Search)

- 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘
- 원래 그래프에서 모든 노드를 방문하기 위한 알고리즘
  - 그래프는 노드와 엣지로 이루어진 자료구조

## Flood Fill

- 그림판의 페인트 기능
- 외부 윤곽선을 따라 구분되는 영역의 색을 한번에 색칠
- BFS로 구현 가능!

# 동작과 구현

## 동작

- 좌표를 담을 **큐**가 필요

1. 시작하는 칸을 큐에 넣고 방문했다는 표시를 남김
2. 큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 3번을 진행
3. 해당 칸을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
4. 큐가 빌 때 까지 2번을 반복

- 모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일 때 O(N)

## STL pair

- 두 자료형을 묶어서 가지고 다닐 수 있음
- pair 생성: pair<int, int> P
- 첫번째 원소 접근: pair.first
- 두번째 원소 접근: pair.second

## 구현

- ex.cpp 참고
- 코드를 거의 외우다시피 해야 함

# 예시

## BOJ 1926번: 그림

- BOJ/boj1926.cpp 참고

1. 상하좌우로 연결된 그림의 크기를 알아내기
2. 도화지에 있는 모든 그림을 찾아내기

# 응용1 - 거리 측정

## BOJ 2178번: 미로 탐색

- BOJ/boj2178.cpp 참고
- 각 칸은 출발지에서부터 얼마만큼 떨어져 있는지에 대한 거리를 가짐

# 응용2 - 시작점이 여러 개일 때

## BOJ 7576번: 토마토

- BOJ/boj7576.cpp 참고
- 시작점이 여러 개인 BFS를 돌려면 시작점들을 미리 큐에 넣으면 됨!!

## BFS의 성질

- 시작점에서부터 BFS를 돌며 거리를 잴 때 큐에 쌓이는 순서는 반드시 거리 순!!
- 시작점이 여러 개일 때도 성립

# 응용3 - 시작점이 두 종류일 때

## BOJ 4179번: 불!

- BOJ/boj4179.cpp
- 이 예제는 시작점이 두 종류일때 서로 영향을 끼치지 않고 불의 전파가 지훈이의 이동에만 영향을 끼침
  - 불만 먼저 전파시키고 지훈이를 이동시키는게 가능
- 하지만 두 종류의 BFS가 서로 영향을 준다면?
  - ex) 불과 소방수, 불과 물의 전파 등
  - 다른 하나만 먼저 전파시키는 것은 불가능
  - 두 종류의 BFS를 시간 순으로 동시에 진행시켜야 함
  - 문제를 많이 풀어봐야 함!

# 응용4 - 1차원에서의 BFS

## BOJ 1697번: 숨바꼭질

- BOJ/boj1697.cpp
- 다른 BFS들과는 다르게 1차원이라 BFS문제라고 인지하기 어려움
- 2차원일 때와 비슷하게 현재 위치에서 1번만에 갈 수 있는 위치들을 큐에 넣고 현재 위치의 시간+1 하면 됨
- 범위에 주의해야 함!!
  - 수빈이와 동생의 위치가 0에서 100,000사이라고 했지 **수빈이가 이동 중에 0에서 100,000사이를 벗어나면 안된다는 조건은 없다!!**
  - 이 문제는 0과 100,000사이를 벗어나면 손해이기 때문에 어차피 0에서 100,000사이에서 답이 나옴
  - 하지만 다른 문제를 풀 때 범위를 섣부르게 단정지으면 안된다!!
