# 정의와 성질

## 배열의 정의

- 메모리 상에 원소를 연속하게 배치한 자료구조

## 배열의 성질

1. O(1)에 k번째 원소를 확인/변경 가능
   - 시작 주소에서 k만큼 오른쪽으로 가면 되기 때문에 O(1) 걸림
2. 추가적으로 소모되는 메모리의 양(=overhead)가 거의 없음
3. Cache hit rate가 높음
   - 메모리 상에 데이터들이 붙어있기 때문
4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

# 기능과 구현

- 임의의 위치에 있는 원소를 확인/변경 -> O(1)
- 원소를 맨 끝에 추가 -> O(1)
- 마지막 원소를 제거 -> O(1)
- 임의의 위치에 원소를 추가 -> **O(N)**
  - 원소를 추가한 인덱스부터 그 뒤의 원소들을 전부 한 칸씩 밀어야 함
- 임의의 위치에 있는 원소를 제거 -> **O(N)**
  - 원소를 추가한 인덱스부터 그 뒤의 원소들을 전부 한 칸씩 땡겨와야 함

## 구현

- ex1.cpp 보기!

## 배열 초기화 팁

1. memset함수
   - 비추천!!!
   - 0이 아닌 값을 넣으면 오작동
   - 2차원 이상 배열을 함수의 인자로 넘겨 memset하면 잘못 들어감
2. for문
   - 실수할 여지X
   - 무난함
3. fill함수
   - algorithm헤더에 포함
   - 실수할 여지X
   - fill(arr, arr+배열크기, 초기화할 값);
   - 2차원 배열에서는 for문안에 fill함수를 사용하면 됨

# STL vector

- 배열과 거의 동일한 기능을 수행함
- 배열과 마찬가지로 원소가 메모리에 연속하게 저장되어 있어 O(1)에 인덱스를 가지고 각 원소로 접근 가능
- 배열과 달리 크기를 자유자재로 늘이거나 줄일 수 있는 장점
- 그래프의 인접 리스트를 저장할 때 편함
- insert와 erase가 메소드로 이미 구현되어있음
  - STL의 iterator개념 필요
- insert, erase -> O(N)
- push_back, pop_back -> O(1)
- '='을 사용하면 deep copy 발생
  - 복사한 vector의 값을 바꿔도 원본에는 영향X
- range-based for loop
  - C++11부터 추가된 기능
  - for(int e : v)
    - e에 v의 원소들이 하나씩 들어가는 for문
  - int e : v -> 복사된 값이 e에 들어감
  - int &e : v -> 원본 값이 e에 들어감
    - e를 바꾸면 원본 값도 바뀜
- for(int i=0; i **<= v.size()-1**; i++) 이렇게 쓰지 말것!!
  - < v.size() 로 쓰자!!
  - vector의 size메소드는 unsigned int를 반환
  - v가 빈 벡터일 때 unsigned int overflow 발생

# 연습문제

- 배열을 이용해 시간복잡도를 줄임

## BOJ 10808번: 알파벳 개수

- BOJ/boj10808.cpp

## 기초코드1 강의 연습문제2번

- 길이 N의 int배열에서 서로 다른 위치의 두 원소가 존재하면 1, 아니면 0리턴
- O(N^2)이였던 시간복잡도를 O(N)으로 바꿔봄
- ex2.cpp
