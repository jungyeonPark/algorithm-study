# 시간, 공간복잡도

- 컴퓨터는 1초에 대략 3-5억 개 정도의 연산 처리 가능

## Big-O Notation

- O(1) < O(lgN) < O(N) < O(NlgN) < O(N^2) < O(2^N) < O(N!)

## 시간복잡도

- 크기 N인 배열을 정렬할 때 시간제한이 1초
  - O(N^2) 불가능
  - O(NlgN) 가능
- 예제 보기

## 공간복잡도

- 2차원 배열이 필요하면 O(N^2), 배열이 필요 없으면 O(1)
- 메모리 제한이 512MB일 때 int변수를 대략 1.2억개 선언 가능(int 하는 4바이트이므로)

# 정수 자료형

- char(1byte), short(2bytes), int(4bytes), long long(8bytes)
- char

  - 8bit중 맨 왼쪽 비트가 2^-7 (2의 보수)
  - 10000011은 -125
  - 최솟값 -128, 최댓값 127

- unsigned char
  - 8bit중 맨 왼쪽 비트가 2^7
  - 10000011은 131
  - 최솟값 0, 최댓값 255

## Integer Overflow

- 컴퓨터는 그냥 시킨 대로 계산하기 때문!
- 1byte인 char에서 01111111(127) + 00000001(1) = 10000000(-128)
- 127 + 1 = -128이 된다

# 실수 자료형

- float(4bytes), double(8bytes)
- 3.75 = 2^1 + 2^0 + 2^-1 + 2^-2 = 11.11(2)
- 10진수의 무한소수처럼 2진수도 무한소수 존재
- sign, exponent, fraction field로 나뉜다.
  - sign: 음수인지 양수인지
  - exponent: 과학적 표기법에서 지수를 저장
  - fraction: 유효숫자

## 실수의 저장/연산 과정에서 반드시 오차가 발생한다.

- 0.1 + 0.1 + 0.1 == 0.3 은 거짓
- 유효숫자가 들어가는 fraction필드가 유한하기 때문
- 0.1은 2진수로 나타내면 무한소수여서 오차가 있는 채 저장이 되고 이것을 3번 더하니 오차가 더 커짐
- fraction 필드로 어디까지 정확하게 표현 가능할까?
  - float는 유효숫자가 6자리 -> 상대오차 10^-6까지 안전
  - double은 유효숫자가 15자리 -> 상대오차 10^15까지 안전
- 상대오차 10^-15의 의미는 원래 값이 1일 때 1-10^-15에서 1+10^-15사이의 값을 가진다는 의미
- float보다 double을 쓰자

## double에 long long범위 정수를 함부로 담으면 안된다.

- double의 유효숫자는 15자리, long long은 최대 19자리
- double은 10^18 + 1과 10^18 구별 불가

## 실수를 비교할 때는 등호를 사용하면 안된다.

- 두 실수가 같은지 알고 싶을 때는 둘의 차이가 아주 작은 값, 대략 10^-12이하면 동일하다고 처리하는게 안전
  - a == b (X)
  - abs(a-b) < 1e-12 (O)
