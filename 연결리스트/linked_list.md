# 정의와 성질

## 연결 리스트의 정의

- 원소들을 저장할 때 그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조
- 원소들은 이곳 저곳에 흩어져있음

## 연결 리스트의 성질

1. k번째(임의의) 원소를 확인/변경하기 위해 O(k)가 필요
   - k번째 원소까지 앞에서부터 순서대로 찾아가야 하기 때문
2. 임의의 위치에 원소를 추가/임의 위치의 원소 제거는 **O(1)**
   - 추가/제거할 주소를 알고있는 경우!
     - 임의의 원소를 추가/제거할 위치까지 찾아가는 시간 생략
   - 가리키는 주소만 바꿔주면 됨
3. 원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움

## 연결 리스트의 종류

- 단일 연결 리스트(Singly Linked List)
  - 다음 노드의 주소만 저장
- 이중 연결 리스트(Doubly Linked List)
  - 이전 노드와 다음 노드의 주소를 저장
  - STL의 list 컨테이너
- 원형 연결 리스트(Circular Linked List)
  - 맨 마지막 노드와 맨 앞의 노드가 연결
  - 단일, 이중 연결 리스트 둘 다 가능

## 배열 vs 연결리스트

- 면접 대비 알아두기
- k번째 원소의 접근
  - 배열: O(1)
  - 연결 리스트: O(k)
- 임의 위치에 원소 추가/제거
  - 배열: O(N)
  - 연결 리스트: O(1)
- 메모리 상의 배치
  - 배열: 연속
  - 연결 리스트: 불연속
- 오버헤드(추가적으로 필요한 공간)
  - 배열: X
  - 연결 리스트: O(N)
    - 다음 원소의 주소값을 가지고 있어야 하기 때문
    - 32비트 컴퓨터면 4N 바이트(주소값이 4바이트 단위), 64비트 컴퓨터면 8N 바이트(주소값이 8바이트 단위)의 메모리 필요

# 기능과 구현

## 임의의 위치에 있는 원소를 확인/변경, O(N)

- 임의의 위치에 있는 원소로 도달할 때까지 첫번째부터 순차적으로 방문해야 함

## 임의의 위치에 원소를 추가, O(1)

- 이전 노드의 다음 주소와 추가할 노드의 다음 주소만 바꾸면 됨(단일 연결 리스트의 경우)
- 추가하고 싶은 위치의 주소를 알고 있을 경우!

## 임의 위치의 원소를 제거, O(1)

- 이전 노드의 다음 주소만 바꾸면 됨(단일 연결 리스트의 경우)
- 추가하고 싶은 위치의 주소를 알고 있을 경우!

## 연결 리스트를 사용하는 예

- 임의의 위치를 알고있을 때 그 위치에 원소를 추가하거나 제거하는 연산을 많이 하는 경우에 유리
- ex) 메모장 같은 텍스트 에디터
  - 커서가 가리키는 위치에 글자를 추가/삭제하는 명령을 수행

## 연결리스트의 구현

- 원래 연결 리스트는 NODE구조체나 클래스를 만들어 원소가 생성될 때 동적할당하는 방식
- 코딩테스트에서는 그냥 STL list를 활용하면 됨
- STL을 허용하지 않는 코딩테스트에서는 구현 난이도가 낮은 야매 연결리스트로 구현

## 야매 연결 리스트

- 원소를 배열로 관리
- pre와 nxt에 이전/다음 원소의 포인터 대신 배열의 인덱스를 저장
- 메모리 누수 때문에 실무에서는 절대 쓸 수 없음
- 일반적인 연결리스트보다 구현 난이도가 낮고 시간복잡도는 동일

```cpp
const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused = 1;

fill(pre, pre+MX, -1);
fill(nxt, nxt+MX, -1);
```

- dat[i]는 i번지 원소의 값
- pre[i]는 i번지 원소에 대해 이전 원소의 인덱스
- nxt[i]는 i번지 원소에 대해 다음 원소의 인덱스
- pre나 nxt의 값이 -1이면 해당 원소의 이전/다음 원소가 존재하지 않음
- unused는 새로운 원소가 들어갈 수 있는 인덱스, 원소가 추가된 이후에 1씩 증가
- 0번지는 연결리스트의 시작 원소로 고정해서 값이 들어가지 않는 dummy node
- 코드는 ex.cpp참고!!

### insert함수

1. 새로운 원소를 생성
2. 새 원소의 pre 값에 삽입할 위치의 주소를 대입
3. 새 원소의 nxt 값에 삽입할 위치의 nxt 값을 대입
4. 삽입할 위치의 nxt 값과 삽입할 위치의 다음 원소의 pre 값을 새 원소로 변경
5. unused 1증가

### erase함수

1. 이전 위치의 nxt를 삭제할 위치의 nxt로 변경
2. 다음 위치의 pre를 삭제할 위치의 pre로 변경

# STL list

- list 생성: list\<int> L
- 주소 역할을 하는 iterator 생성: list\<int>::iterator t = L.begin()
  - C++11 이상일 때 auto t = L.begin()도 가능
  - t가 가리키는 값을 출력: \*t
- 맨 앞에 k 추가: L.push_front(k)
- 맨 뒤에 k 추가: L.push_back(k)
- t가 가리키는 곳 앞에 k를 삽입: L.insert(t, k)
- t가 가리키는 값을 제거: L.erase(t)
  - list에서는 t의 값을 제거한 후 t가 다음 값을 가리키지 않고 가리키던 위치를 잃어버림
  - t = L.erase(t) 와 같이 erase의 리턴값을 이용해야 함

# 연습 문제

## BOJ 1406번: 에디터

- 시간 제한: 0.3초 -> N이 5000이 넘어서 O(N^2) 불가능
- 연결리스트로 해결해야 함
- 배열은 삽입/삭제 O(N)에 명령어 개수 O(M)만큼 돌아서 그런듯??
- STL list: BOJ/boj1406-1.cpp
- 야매연결리스트: BOJ/boj1406-2.cpp

## 손코딩 문제

### 1. 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때 해당 List의 길이를 효율적으로 구하는 방법?

- 동일한 노드가 나올 때까지 계속 다음 노드로 가면 됨
- 공간복잡도 O(1), 시간복잡도 O(N)

### 2. 중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때 만나는 지점을 구하는 방법?

- 일단 두 시작점 각각에 대해 끝까지 진행시켜서 각각의 길이를 구함
- 그 후 다시 두 시작점으로 돌아와서 더 긴 쪽을 둘의 차이만큼 앞으로 먼저 이동시켜놓고 두 시작점이 만날 때까지 두 시작점을 동시에 한 칸씩 전진시키면 됨
- 공간복잡도 O(1), 시간복잡도 O(A+B)

### 3. 주어진 연결 리스트 안에 사이클이 있는지 판단하라

- Floyd's cycle-finding algorithm
- 한 칸씩 가는 커서와 두 칸씩 가는 커서를 동일한 시작점에서 출발시키면 사이클이 있을 경우 두 커서는 반드시 만나게 됨
- 만약 사이클이 없으면 두 커서가 만나지 못하고 연결리스트의 끝에 도달
- 이 방식을 이용하면 거치는 모든 노드를 저장할 필요 없이 공간복잡도 O(1)에 사이클 존재 여부 확인 가능
- 공간복잡도 O(1), 시간복잡도 O(N)
