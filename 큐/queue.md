# 정의와 성질

## 큐의 정의

- 한쪽 끝에서 원소를 넣고 반대쪽 끝에서 원소를 뺄 수 있는 자료구조
- 먼저 들어간 원소가 먼저 나오는 FIFO(First in First Out) 자료구조

## 큐의 성질

1. 원소의 추가/제거가 O(1)
2. 제일 앞/뒤의 원소 확인이 O(1)
   - 스택에서는 원소가 추가/제거되는 곳을 top이라고 부르고 원소가 위아래로 배치된 것으로 생각을 많이 하는데
   - 큐에서는 추가되는 곳을 rear, 뒤쪽이라고 하고 제거되는 곳을 front, 앞쪽이라고 함
3. 제일 앞/뒤가 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가능
   - 자료구조에서는 인덱스를 가지고 원소에 접근하는 기능이 없지만, 배열로 직접 구현하면 가능하게 만들 수 있음
   - STL queue에서는 없다

# 기능과 구현

- 큐 역시 연결리스트보다 배열 구현이 더 쉬움
- 원소를 담을 배열 한개와 앞쪽, 뒤쪽을 가리킬 변수 두 개 필요

```cpp
const int MX = 1000005;
int dat[MX];
int head = 0, tail = 0;
```

- head: 가장 앞에 있는 원소의 인덱스
- tail: 가장 뒤에 있는 원소의 인덱스 + 1
- 원소가 push될 때마다 tail이 증가하고 pop될 때마다 head가 증가
- dat배열에서 dat[head]부터 dat[tail-1]까지 큐의 원소들이 들어있음
- 큐의 크기는 tail - head
  - 큐가 비어있으면 tail == head
  - tail - 1 == head 일 때는 원소가 하나 있을때
- ex.cpp 참고!

## push 함수

- tail이 가리키는 자리에 원소를 추가하고 tail을 1증가

## pop 함수

- head를 1증가

## front/back 함수

- front 함수는 제일 앞에 위치한 원소를 반환하는 함수로 dat[head]를 반환
- back 함수는 제일 뒤에 위치한 원소를 반환하는 함수로 dat[tail - 1]을 반환

## 원형 큐

- 원소가 push될 때마다 tail이 증가하고 pop될 때마다 head가 증가
- 배열이 점점 오른쪽으로 밀림
- 앞쪽의 배열을 사용하지 않아 공간 낭비 발생
- 해결 방법: 배열을 원형으로 만듦!!
- 관념적으로 배열은 원형이지만 실제 구현할 때는 배열 크기만큼 다 사용되었으면 다시 0번지로 오도록 만듦
- STL안쓰고 직접 구현한다면 원형 큐로 만드는게 좋음
- 하지만 코딩테스트에서는 어차피 push 최대 횟수가 정해져있으므로 굳이 원형 큐를 만들지 않아도 됨

# STL queue

- 큐 생성: queue\<int> Q
- 큐에 k를 push: Q.push(k)
- 큐의 size를 리턴: Q.size()
- 큐가 비었으면 1, 아니면 0 리턴: Q.empty()
- 큐에서 pop: Q.pop()
  - 큐가 비어있을 때 호출하면 런타임에러
- 큐에서 가장 앞에 있는 원소를 리턴: Q.front()
  - 큐가 비어있을 때 호출하면 런타임에러
- 큐에서 가장 끝에 있는 원소를 리턴: Q.back()
  - 큐가 비어있을 때 호출하면 런타임에러

# 연습문제

## BOJ 10845번: 큐

- STL queue: BOJ/boj10845-1.cpp
- 직접 구현: BOJ/boj10845-2.cpp
